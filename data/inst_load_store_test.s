.org 0x0  
.set noat  
.set noreorder  
.set nomacro  
.global _start  
_start:  
  
##############       第一段：测试sb、lb、lbu指令      ################  
  
ori  $3,$0,0xeeff     # $3 = 0x0000eeff  
sb   $3,0x3($0)       # 向RAM地址0x3处存储0xff, [0x3] = 0xff  
  
srl  $3,$3,8          # 逻辑右移8位, $3 = 0x000000ee  
sb   $3,0x2($0)       # 向RAM地址0x2处存储0xee, [0x2] = 0xee  
  
ori  $3,$0,0xccdd     # $3 = 0x0000ccdd  
sb   $3,0x1($0)       # 向RAM地址0x1处存储0xdd, [0x1] = 0xdd  
  
srl  $3,$3,8          # 逻辑右移8位, $3 = 0x000000cc  
sb   $3,0x0($0)       # 向RAM地址0x0处存储0xcc, [0x0] = 0xcc  
  
lb   $1,0x3($0)       # 加载0x3处的字节并作符号扩展, $1 = 0xffffffff  
lbu  $1,0x2($0)       # 加载0x2处的字节并作无符号扩展, $1 = 0x000000ee  
  
################       第二段：测试sh、lh、lhu指令     ##############  
  
ori  $3,$0,0xaabb     # $3 = 0x0000aabb  
sh   $3,0x4($0)       # 向RAM地址0x4处存储0xaabb,   
# [0x4] = 0xaa, [0x5] = 0xbb  
  
lhu  $1,0x4($0)       # 加载0x4处的半字并作无符号扩展, $1 = 0x0000aabb  
lh   $1,0x4($0)       # 加载0x4处的半字并作符号扩展, $1 = 0xffffaabb  
  
ori  $3,$0,0x8899     # $3 = 0x00008899  
sh   $3,0x6($0)       # 向RAM地址0x6处存储0x8899,   
# [0x6] = 0x88, [0x7] = 0x99  
  
lh   $1,0x6($0)       # 加载0x6处的半字并作符号扩展, $1 = 0xffff8899  
lhu  $1,0x6($0)       # 加载0x6处的半字并作无符号扩展, $1 = 0x00008899  
  
################     第三段：测试sw、lw、lwl、lwr指令   ##############  
  
# 经过上面指令的执行，此时RAM的内容如下  
# [0x0] = 0xcc, [0x1] = 0xdd  
# [0x2] = 0xee, [0x3] = 0xff  
# [0x4] = 0xaa, [0x5] = 0xbb  
# [0x6] = 0x88, [0x7] = 0x99  
  
ori  $3,$0,0x4455  
sll  $3,$3,0x10  
ori  $3,$3,0x6677     # $3 = 0x44556677  
sw   $3,0x8($0)       # 向RAM地址0x8处存储0x44556677,  
                      # [0x8] = 0x44, [0x9] = 0x55,   
                      # [0xa] = 0x66, [0xb] = 0x77  
  
lw   $1,0x8($0)       # 加载0x8处的字, $1 = 0x44556677  
  
lwl  $1,0x5($0)       # 非对齐加载指令lwl，执行后使得$1 = 0xbb889977，  
                      # 读者可以结合图9-8理解  
  
lwr  $1,0x8($0)       # 非对齐加载指令lwr，执行后使得$1 = 0xbb889944，  
                      # 读者可以结合图9-10理解  
  
nop  
  
################      第四段：测试swl、swr指令       ################  
  
swr  $1,0x2($0)       # 非对齐存储指令swr，执行效果如下  
                      # [0x0] = 0x88, [0x1] = 0x99,   
                      # [0x2] = 0x44, [0x3] = 0xff  
                      # 读者可以结合图9-16理解  
  
swl  $1,0x7($0)       # 非对齐存储指令swl，执行效果如下  
                      # [0x4] = 0xaa, [0x5] = 0xbb,   
                      # [0x6] = 0x88, [0x7] = 0xbb  
                      # 读者可以结合图9-14理解  
  
lw   $1,0x0($0)       # 加载RAM地址0x0处的字, $1 = 0x889944ff,  
                      # 验证swr指令的执行效果  
  
lw   $1,0x4($0)       # 加载RAM地址0x4处的字, $1 = 0xaabb8844,  
                      # 验证swl指令的执行效果  
  
_loop:  
j _loop  
nop  
